// Generated by CoffeeScript 1.12.7
(function() {
  var config, exec, hash;

  exec = require('child_process').exec;

  hash = require('object-hash');

  config = require('./config.json');

  String.prototype.count = function(search) {
    var c, m;
    m = this.match(new RegExp(search.toString(), 'gm'));
    return c = m ? m.length : 0;
  };

  String.prototype.extract = function(regx, index) {
    var pattern, result;
    pattern = new RegExp(regx.toString());
    if (this.match(pattern)) {
      result = this.match(pattern);
      return result[index];
    } else {
      return 0;
    }
  };

  String.prototype.capitalizeAll = function() {
    return this.replace(/(^|\s)([a-z])/g, function(m, p1, p2) {
      return p1 + p2.toUpperCase();
    });
  };

  Array.prototype.merge = function(other) {
    return Array.prototype.push.apply(this, other);
  };

  exec('/usr/bin/osascript ' + __dirname + '/FinderFolders.scpt', function(error, stdout, stderr) {
    var additionals_paths, data, gitpaths, gitrepos, parsedpath, paths;
    paths = stdout.trim().split(',');
    additionals_paths = config.additionals_paths;
    paths.merge(additionals_paths);
    parsedpath = 0;
    data = {};
    gitrepos = [];
    gitpaths = [];
    if (paths.length > 0) {
      return paths.forEach(function(p, i) {
        var thepath;
        thepath = p.trim();
        return exec('git rev-parse --show-toplevel', {
          cwd: thepath
        }, function(error, stdout, stderr) {
          if (error === null) {
            gitpaths.push(stdout.trim());
          }
          parsedpath++;
          if (parsedpath === paths.length) {
            gitpaths = Array.from(new Set(gitpaths));
            parsedpath = 0;
            return gitpaths.forEach(function(g, j) {
              var gitpath;
              gitpath = g.trim();
              return exec('git status >/dev/null 2>&1 && echo "$(git status -b --porcelain --ignored)" && echo "BRANCHES:$(git branch -v | wc -l | sed \'s/ //g\')" && echo "STASH:$(git stash list | wc -l | sed \'s/ //g\')"  && echo "SIZE:$(du -h -d0 |awk \'{print $1}\')"  && echo "NAME:$(basename \"$(git rev-parse --show-toplevel)\")" || exit 1;', {
                cwd: gitpath
              }, function(error, stdout, stderr) {
                var GitStatus, GitStatusInfo, repo;
                GitStatus = stdout.trim();
                if (error === null) {
                  GitStatusInfo = GitStatus.split('\n')[0];
                  repo = {
                    path: gitpath,
                    name: GitStatus.extract('NAME:(.*)$', 1).replace(/[_-]+/g, ' ').capitalizeAll(),
                    branch: GitStatusInfo.extract('## (([A-Za-z0-9-_]+)[.]{0,3})', 2),
                    remote: GitStatusInfo.extract('[.]{3}(\\S+)', 1),
                    ahead: GitStatusInfo.extract('ahead (\\d+)', 1),
                    behind: GitStatusInfo.extract('behind (\\d+)', 1),
                    branches: GitStatus.extract('BRANCHES:(\\d)', 1),
                    stash: GitStatus.extract('STASH:(\\d)', 1),
                    size: GitStatus.extract('SIZE:(.*)', 1),
                    stats: {
                      added: GitStatus.count('^[AM]'),
                      modified: GitStatus.count('^ M'),
                      untracked: GitStatus.count('^\\?\\?'),
                      ignored: GitStatus.count('^!!')
                    },
                    hash: ''
                  };
                  repo['hash'] = hash(repo.path);
                  gitrepos.push(repo);
                }
                parsedpath++;
                if (parsedpath === gitpaths.length) {
                  data.gitrepos = gitrepos;
                  if (config.prefs) {
                    data.prefs = config.prefs;
                  }
                  return console.log(JSON.stringify(data));
                }
              });
            });
          }
        });
      });
    }
  });

}).call(this);
